Introduction to Go
GDG Korea DevFair 2014


장재휴
Developer, Purpleworks
jaehue@jang.io

* Simple can be harder than complex
 
.image introduction_to_go/simple_can_be_harder_than_complex2.jpg 430 _

_단순함은_복잡함보다_어렵다_.
_생각을_명쾌하게_해_단순하게_만드려면_굉장히_노력해야_한다_.
_하지만_결국_그럴_가치가_있다_. _일단_단순함에_도달하면,_산을_움직일_수_있기_때문이다_.

* Agenda

- What is Go
- OOP in Go
- Concurrency in Go
- Real world Go

.image introduction_to_go/devfair2014_2.png _ 550
.image introduction_to_go/go-logo.jpg

* What is Go

* Why Go?

- Statically typed languages ➔ Efficient vs. Hard to write
- Dynamic language ➔ Easy to use vs. Slow & error-prone
- Speed, Safety, Ease to use
- Concurrent programming is hard(thread, lock, mutex)

* What is go

- A modern, general purpose language.
- open source
- Statically typed languages
- Feel dynamically
- concurrents
- garbage-collected
- efficient
- simply

* OOP in Go

* 1. Object via struct and methods

- Go lacks Classes. Go lacks "Objects"
- But Go is object-based

* Object in Go

.play introduction_to_go/object1.go

* Object in Go II

.play introduction_to_go/object2.go /START OMIT/,/END OMIT/

* 2. Composition over inheritance

- Go avoided inheritance
- Go strictly follows the *Composition* *over* *inheritance* principle
- Composition provides reuse of Objects

* Composition in Go
.play introduction_to_go/composition1.go /START OMIT/,/END OMIT/

* Composition in Go II
.play introduction_to_go/composition2.go /START OMIT/,/END OMIT/

* 3. Polymorphism via interfaces

- Interfaces are just sets of methods
- Interfaces define behavior (duck typing)
- "If something can do this, then it can be used here"

* Interfaces in Go
.code introduction_to_go/interface.go /START1 OMIT/,/END1 OMIT/ HLinterface

* Interfaces in Go II
.play introduction_to_go/interface.go /START OMIT/,/END OMIT/

* The Power of Interfaces

- Fprintln function in standard *"fmt"* package

  func Fprintln(w io.Writer, a ...interface{}) (n int, err error)

- Writer interface in standard *"io"* package

 // http://godoc.org/io#Writer
 type Writer interface {
     Write(p []byte) (n int, err os.Error)
 }


* The Power of Interfaces

In handle function, just write to *io.Writer* object

 func handle(w io.Writer, msg string) {
     fmt.Fprintln(w, msg)
 }

The *os.Stdout* define Write function. It can be used for *io.Writer*.

.play introduction_to_go/interface2.go /START OMIT/,/END OMIT/

* The Power of Interfaces

The *http.ResponseWriter* define Write function too. It can be used for *io.Writer*.
The *io* package doesn’t know *http*. It just works.

.play introduction_to_go/interface3.go /START OMIT/,/END OMIT/

.link http://localhost:4000/hello-world localhost:4000/hello-world
.link http://localhost:4000/this-is-an-example-of-io.Writer localhost:4000/this-is-an-example-of-io.Writer

* Concurrency in Go

* What is concurrency

- Concurrency is the *composition* *of* *independently* *executing* *computations*. 
- It is not parallelism.

* Go's Concurrency is
- Easy to understand.
- Easy to use.
- You don't need to be an expert!

* Go's approach

- In UNIX: processes connected by pipes:
 find ~/go/src | grep _test.go$ | xargs wc -l
- In Go: *goroutines* connected by *channels*

* Fundamentals #1 - Goroutine

Goroutines are *independently* *executing* *functions*.

- The go statement launches a function call as a goroutine

 go f()
 go f(x, y, ...)

- It's not a thread
- Very lightweight
- A goroutine has its own stack
- A goroutine runs concurrently

* Goroutine example

.play introduction_to_go/goroutine.go /START OMIT/,/END OMIT/

* Fundamentals #2 - Channel-based communication

Channels *allow* *goroutines* *to* *synchronize* *and* *exchange* *information*.

- A channel type specifies a channel value type (and a communication direction):

 chan int
 chan<- string  // send-only channel
 <-chan T       // receive-only channel

- A channel is a variable of channel type:

 var ch chan int
 ch := make(chan int)  // declare and initialize with newly made channel

- A channel permits sending and receiving values:

 ch <- 1   // send value 1 on channel ch
 x = <-ch  // receive a value from channel ch (and assign to x)

- Channel operations synchronize the communicating goroutines.

* Communicating goroutines

.play introduction_to_go/channel.go /START OMIT/,/END OMIT/

* Communicating goroutines II

.play introduction_to_go/pingpong.go /START OMIT/,/END OMIT/

* Philosophy
- Goroutines give the efficiency of an asynchronous model, but you can write code in a synchronous style.
- "Don’t communicate by sharing memory. Instead, share memory by communicating."

* Real world Go

* mixquare.com

- Microchats for everyone
- Instantly create a channel any topic, location or event

* Message Flow

.image introduction_to_go/mixquare_arch.png 500 _

* Action of message processing worker

1. fetch user information
2. fetch channel information
3. save message to datastore
4. publish

* Measure First

- ruby version

- go version

* Concurrency

- RPC-bound jobs are very common
- Excuting next job while waiting

* Concurrency II

- Run synchronously

  u, err1 := msg.fetchUser()
  msg.setUser(u)

  c, err2 := msg.fetchChannel()
  msg.setChannel(c)

  err3 := msg.process()

  if err1 != nil || err2 != nil || err3 != nil {
    /* ... */
  }

* Concurrency III

- Run concurrently

.code -numbers introduction_to_go/mixquare_concurrency.go

* Concurrency IV

- Result:

* Caching

- Using SQL can be slow
- Using redis is good, but *fault* *tolerance* *is* *too* *hard*.
- *Solution*: Timeout waiting

* Caching with control variance

.code introduction_to_go/mixquare_fetch_user.go /START1 OMIT/,/END1 OMIT/

* Before and After

- Ruby version:

- Baseline: 

- Concurrency:

- Caching:

* Conclusion

*  Go is... not so great

Go is young language