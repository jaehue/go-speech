Introduction to Go
GDG Korea DevFair 2014

장재휴
Developer, Purpleworks
jaehue@jang.io

* Agenda

- Feature of Go
- OOP in Go
- Concurrency in Go
- Real world Go

.image introduction_to_go/go-logo.jpg

* Feature of Go

* Why Go?

- Statically typed languages: Efficient / Hard to write
- Dynamic language: Easy to use / Slow, error-prone
- Concurrent programming is hard(thread, lock, mutex)
- Trade off: Speed, Safety, Ease to use

* What is go

- A modern, general purpose language.
- open source
- Statically typed languages
- Feel dynamically
- concurrents
- garbage-collected
- efficient
- simply
- fun

* Important stuff

- Strong and Static types
- Object oriented without class and inheritance
- Struct, Functions and Methods (with receivers)
- Interfaces, but no declaration (duck typing)
- No exceptions (error interface)
- Visibility with the first letter of symbol

* OOP in Go

* What is "Object Oriented" (wikipedia)

- A language is usually considered *object-based* if it *includes* *the* *basic* *capabilities* *for* *an* *object*: identity, properties, and attributes 

- A language is considered *object-oriented* if it *is* *object-based* and also *has* *the* *capability* *of* *polymorphism* *and* *inheritance*

* Is Go Object-based Language?

* What is an "Object" (wikipedia)

-  An object is an abstract data type that has *state(data)* and *behavior(code)*

* Object in Go

.play introduction_to_go/object1.go

* Object in Go

.play introduction_to_go/object2.go /START OMIT/,/END OMIT/

* Go is Object-based

- Via struct and methods

* Is Go Object-oriented Language?

* What is "Inheritance" (wikipedia)

- Provides reuse of existing objects
- Classes are created in hierarchies
- Inheritance passes *knowledge* down!

* Inheritance is not good

_I_once_attended_a_Java_user_group_meeting_where_James_Gosling_(Java’s_inventor)_was_the_featured_speaker_.

_During_the_memorable_Q&A_session,_someone_asked_him_:
_“If_you_could_do_Java_over_again,_what_would_you_change?”_

_“I’d_leave_out_classes,”_
_he_replied_.

_After_the_laughter_died_down,_he_explained_that_the_real_problem_wasn’t_classes_per_se,_
_but_rather_implementation_inheritance_(the_extends_relationship)._

_Interface_inheritance_(the_implements_relationship)_is_preferable._

*You*should*avoid*implementation*inheritance*whenever*possible*.

* Go's approach

- Go avoided inheritance
- Go strictly follows the *Composition* *over* *inheritance* principle
# or Composite Reuse Principle

* What is Composition
- Provides reuse of Objects
- One object is declared by containing other objects
- Composition pulls *knowledge* into another

* Composition in Go
.play introduction_to_go/composition1.go /START OMIT/,/END OMIT/

* Composition in Go
.play introduction_to_go/composition2.go /START OMIT/,/END OMIT/

* What is "Polymorphism" (wikipedia)
- The provision of a single interface to entities of different types
- Via *Generics*, *Overloading* and/or *Subtyping*

* Go’s approach
- Go avoided subtyping & overloading
- Go does not provide Generics
- Polymorphism via interfaces

* Interfaces in Go
- Interfaces are just sets of methods
- Interfaces define behavior (duck typing)
- "If something can do this, then it can be used here"

* Interfaces in Go
.play introduction_to_go/interface.go /START OMIT/,/END OMIT/

* Interfaces in Go
.code introduction_to_go/interface.go /START1 OMIT/,/END1 OMIT/

* The Power of Interfaces

Writer interface in standard *"io"* package

 // http://godoc.org/io#Writer
 type Writer interface {
     Write(p []byte) (n int, err os.Error)
 }

- Write writes up to len(p) bytes into p
- Returns the # of bytes written & any error
- Does not dictate how Write() is implemented
- Used by fmt.Fprint, os.File, bytes.Buffer, net.Conn, http.Response.Body, etc.

* The Power of Interfaces

In handle function, just write to *io.Writer* object

 func handle(w io.Writer, msg string) {
     fmt.Fprintln(w, msg)
 }

The *os.Stdout* define Write function. It can be used for *io.Writer*.

.play introduction_to_go/interface2.go /START OMIT/,/END OMIT/

* The Power of Interfaces

The *http.ResponseWriter* define Write function too. It can be used for *io.Writer*.
The *io* package doesn’t know *http*. It just works.

.play introduction_to_go/interface3.go /START OMIT/,/END OMIT/

.link http://localhost:4000/hello-world localhost:4000/hello-world
.link http://localhost:4000/this-is-an-example-of-io.Writer localhost:4000/this-is-an-example-of-io.Writer

* Go is Object-Oriented

* Concurrency in Go

* What is concurrency

- Concurrency is the *composition* *of* *independently* *executing* *computations*. 
- It is not parallelism.

* Go's Concurrency is:
- Easy to understand.
- Easy to use.
- You don't need to be an expert!

* Go's approach

- In UNIX: processes connected by pipes:
 find ~/go/src | grep _test.go$ | xargs wc -l
- In Go: *goroutines* connected by *channels*

* Fundamentals #1 - Goroutine

Goroutines are *independently* *executing* *functions* in the same address space.

- The go statement launches a function call as a goroutine

 go f()
 go f(x, y, ...)

- It's not a thread
- Very lightweight
- A goroutine has its own stack
- A goroutine runs concurrently (but not necessarily in parallel)

* A simple example

.play introduction_to_go/goroutine.go /START OMIT/,/END OMIT/

* Fundamentals #2 - Channel-based communication

Channels *allow* *goroutines* *to* *synchronize* *and* *exchange* *information*.

- A channel type specifies a channel value type (and a communication direction):

 chan int
 chan<- string  // send-only channel
 <-chan T       // receive-only channel

- A channel is a variable of channel type:

 var ch chan int
 ch := make(chan int)  // declare and initialize with newly made channel

- A channel permits sending and receiving values:

 ch <- 1   // send value 1 on channel ch
 x = <-ch  // receive a value from channel ch (and assign to x)

- Channel operations synchronize the communicating goroutines.

* Communicating goroutines

.play introduction_to_go/channel.go /START OMIT/,/END OMIT/

* Communicating goroutines

.play introduction_to_go/pingpong.go /START OMIT/,/END OMIT/

* Philosophy
- Goroutines give the efficiency of an asynchronous model, but you can write code in a synchronous style.
- "Don’t communicate by sharing memory. Instead, share memory by communicating."

* Go is simple!

_Simple_can_be_harder_than_complex_:_You_have_to_work_hard_to_get_your_thinking_clean_to_make_it_simple_. _But_it's_worth_it_in_the_end_because_once_you_get_there_, _you_can_move_mountains_.
- _Steve_Jobs_ -

_단순함은_복잡함보다_어렵다._생각을_명쾌하게_해_단순하게_만드려면_굉장히_노력해야_한다._하지만_결국_그럴_가치가_있다._일단_단순함에_도달하면,_산을_움직일_수_있기_때문이다_.
 
.image introduction_to_go/stevejobs.png

* Real world Go

* mixquare.com

- Microchats for everyone
- Instantly create a channel any topic, location or event

* Message Flow

.image introduction_to_go/mixquare_arch.png 500 _

* Action of message processing worker

1. fetch user information
2. fetch channel information
3. save message to datastore
4. publish

* Measure First!

- ruby version

- go version

* Concurrency

- RPC-bound jobs are very common
- Excuting next job while waiting

* Concurrency II

- Run synchronously

  err1 := msg.fetchUser()
  err2 := msg.fetchChannel()
  err3 := msg.process()

  if err1 != nil || err2 != nil || err3 != nil {
    /* ... */
  }

* Concurrency III

- Run concurrently

  errc := make(chan error)

  go func() {
    err := msg.fetchUser()
    errc <- err
  }()

  go func() {
    err := msg.fetchChannel()
    errc <- err
  }()

  go func() {
    err := msg.process()
    errc <- err
  }()

  err1, err2, err3 := <-errc, <-errc, <- errc
  if err1 != nil || err2 != nil || err3 != nil {
    /* ... */
  }

* Caching

- Using SQL can be slow
- Using redis is good, but *fault* *tolerance* *is* *too* *hard*.
- *Solution*: Use Go's concurrency to timeout waiting

* Caching with control variance

.code introduction_to_go/fetch_user.go /START1 OMIT/,/END1 OMIT/

* Caching II

- Using redis is good, but a high throughput is expensive
- Using local memory is okay too, but *it* *can* *break* *data* *integrity*
- *Solution*: Use Go's concurrency to flush memory

* Caching with control variance II

.code introduction_to_go/fetch_user.go /START2 OMIT/,/END2 OMIT/

* Before and After

- Baseline: 

- Concurrency:

- Caching:

* Bulk processing

- Processing 100 messages is easier than processing a single message 100 times
- Use goroutine to bulk processing

  deliveries, err := q.Consume()

  for delivery := range deliveries {
    if err := process(d.Body, q); err != nil {
      /* error handling */
    }
  }

* Bulk processing II

- Set QUEUE_PREFETCH_COUNT to 100

  const QUEUE_PREFETCH_COUNT 100

- Processing 100 message simultaneously

  deliveries, err := q.Consume()

  for delivery := range deliveries {
    go func(d amqp.Delivery) {
      if err := process(d.Body, q); err != nil {
        /* error handling */
      }
    }(delivery)
  }

*  Go is... not so great

Go is young language

# mixquare-worker-message-go -amqp-uri=amqp://guest:guest@192.168.81.111:5672 -mongo-uri=mongodb://mixquare:aabb1122@192.168.81.106:27007/mixquare_staging -sql-uri="mysql://mixquare:aabb1122@tcp(192.168.81.106:3306)/mixquare_staging?charset=utf8mb4,utf8" -amqp-prefetch-count=1