Introduction to Go
GDG Korea DevFair 2014

장재휴
Developer, Purpleworks
jaehue@jang.io

* Agenda

- Feature of Go
- OOP in Go
- Concurrency in Go
- Real world Go

* Feature of Go

* Why Go?

- Statically typed languages: Efficient / Hard to write
- Dynamic language: Easy to use / Slow, error-prone
- Concurrent programming is hard(thread, lock, mutex)
- Trade off: Speed, Safety, Ease to use

So, We need:

- Efficiency
- Safety
- Concurrency
- Scalability
- Fast development cycle
- No surprises
- A cute mascot

* What is go

- open source
- concurrent
- garbage-collected
- efficient
- scalable
- simple
- fun
- boring (to some)

* Design of Go

- Lightweight, avoids unnecessary repetition
- Object Oriented, but not in the usual way
- Concurrent, in a way that keeps you sane
- Designed for working programmers

* Who uses?

.image introduction_to_go/go_user.png 480 640

* Principles of Go

- Simple
- Orthogonal
- Succinct
- Safe

Go is statically typed and compiled but in many ways feels as lightweight and dynamic languages

* Important stuff

- Object oriented without class and inheritance
- Syntax sugar declaration
- Strong and Static types
- Interfaces, but no declaration (duck typing)
- Functions and Methods (with receivers)
- No exceptions (error interface)
- Visibility with the first letter of symbol
- Unused imports and variables occurs compile error
- Excellent and complete standard library

* Go is

- Fast
- Friendly
- Concurrent

* OOP in Go

* What is "Object Oriented" (wikipedia)

- A language is usually considered *object-based* if it *includes* *the* *basic* *capabilities* *for* *an* *object*: identity, properties, and attributes 

- A language is considered *object-oriented* if it *is* *object-based* and also *has* *the* *capability* *of* *polymorphism* *and* *inheritance*

* Does Go Have Objects?

- Go lacks Classes
- Go lacks "Objects"

* Is Go Object-based Language?

* What is an "Object" (wikipedia)

-  An object is an abstract data type that has *state(data)* and *behavior(code)*

* Object in Go

.play introduction_to_go/object1.go

* Object in Go

.play introduction_to_go/object2.go /START OMIT/,/END OMIT/

* Is Go Object-oriented Language?

* What is "Inheritance" (wikipedia)

- Provides reuse of existing objects
- Classes are created in hierarchies
- Inheritance passes *knowledge* down!

* Go's approach

- Go explicitly avoided inheritance
- Go strictly follows the *Composition* *over* *inheritance* principle
# or Composite Reuse Principle

* What is Composition
- Provides reuse of Objects
- One object is declared by including other objects
- Composition pulls *knowledge* into another

* Composition in Go
.play introduction_to_go/composition1.go /START OMIT/,/END OMIT/

* Composition in Go
.play introduction_to_go/composition2.go /START OMIT/,/END OMIT/

* What is "Polymorphism" (wikipedia)
- The provision of a single interface to entities of different types
- Via *Generics*, *Overloading* and/or *Subtyping*

* Go’s approach
- Go avoided subtyping & overloading
- Go does not provide Generics
- Polymorphism via interfaces

* Interfaces in Go
- Interfaces are just sets of methods
- Interfaces define behavior
- "If something can do this, then it can be used here"

* Interfaces in Go
.play introduction_to_go/interface.go /START OMIT/,/END OMIT/

* The Power of Interfaces

Writer interface in standard *"io"* package

 // http://godoc.org/io#Writer
 type Writer interface {
     Write(p []byte) (n int, err os.Error)
 }

- Write writes up to len(p) bytes into p
- Returns the # of bytes written & any error
- Does not dictate how Write() is implemented
- Used by fmt.Fprint, os.File, bytes.Buffer, net.Conn, http.Response.Body, etc.

* The Power of Interfaces

In handle function, just write to *io.Writer* object

 func handle(w io.Writer, msg string) {
     fmt.Fprintln(w, msg)
 }

The *os.Stdout* define Write function. It can be used for *io.Writer*.

.play introduction_to_go/interface2.go /START OMIT/,/END OMIT/

* The Power of Interfaces

The *http.ResponseWriter* define Write function too. It can be used for *io.Writer*.
The *io* package doesn’t know *http*. It just works.

.play introduction_to_go/interface3.go /START OMIT/,/END OMIT/

.link http://localhost:4000/hello-world localhost:4000/hello-world
.link http://localhost:4000/this-is-an-example-of-io.Writer localhost:4000/this-is-an-example-of-io.Writer

* Go is simple!

_Simple_can_be_harder_than_complex_:_You_have_to_work_hard_to_get_your_thinking_clean_to_make_it_simple_. _But_it's_worth_it_in_the_end_because_once_you_get_there_, _you_can_move_mountains_.
 - _Steve_Jobs_ -

* Concurrency in Go

* What is concurrency
- Concurrency is a property of systems in which several computations are executing simultaneously
- Concurrency is the composition of independently executing processes.(http://blog.golang.org/concurrency-is-not-parallelism)
- It is not parallelism.

* Go's Concurrency is:
- Easy to understand.
- Easy to use.
- Easy to reason about.
- You don't need to be an expert!

* Go's approach

- In UNIX: processes connected by pipes:
 find ~/go/src | grep _test.go$ | xargs wc -l
- In Go: *goroutines* connected by *channels*

Share data by *Communicating*! (not by sharing memory)

* Fundamentals #1 - Goroutine

Goroutines are *independently* *executing* *functions* in the same address space.

- The go statement launches a function call as a goroutine

 go f()
 go f(x, y, ...)

- Very lightweight processes
- A goroutine runs concurrently (but not necessarily in parallel)
- A goroutine has its own stack

* A simple example

.play introduction_to_go/goroutine.go /START OMIT/,/END OMIT/

* Fundamentals #2 - Channel-based communication

Channels are typed values that *allow* *goroutines* *to* *synchronize* *and* *exchange* *information*.

- A channel type specifies a channel value type (and a communication direction):

 chan int
 chan<- string  // send-only channel
 <-chan T       // receive-only channel

- A channel is a variable of channel type:

 var ch chan int
 ch := make(chan int)  // declare and initialize with newly made channel

- A channel permits sending and receiving values:

 ch <- 1   // send value 1 on channel ch
 x = <-ch  // receive a value from channel ch (and assign to x)

- Channel operations synchronize the communicating goroutines.

* Communicating goroutines

.play introduction_to_go/channel.go /START OMIT/,/END OMIT/

* Communicating goroutines

.play introduction_to_go/pingpong.go /START OMIT/,/END OMIT/

* Philosophy
- Goroutines give the efficiency of an asynchronous model, but you can write code in a synchronous style.
- Easier to reason about: write goroutines that do their specific jobs well, and connect them with channels.
 In practice, this yields simpler and more maintainable code.
- Think about the concurrency issues that matter: 
 "Don’t communicate by sharing memory. Instead, share memory by communicating."

* Real world Go




* Example: unique ID service
.code introduction_to_go/uniqueId.go

* Example: memory recycler
.code introduction_to_go/memoryRecycler.go

* Example: Timeout
.code introduction_to_go/timeout.go

* Example: Heartbeat
.code introduction_to_go/heartbeat.go

* Example: network multiplexor
.code introduction_to_go/networkMultiplexor.go

* Example: first of N
.code introduction_to_go/firstN.go
